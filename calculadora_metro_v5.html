<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metro Madrid Calculator v5.0 - Algoritmos Avanzados</title>
    <style>
        :root {
            --color-primary: #0066cc;
            --color-secondary: #f0f0f0;
            --color-success: #28a745;
            --color-warning: #ffc107;
            --color-danger: #dc3545;
            --color-text: #333;
            --shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .version-badge {
            background: var(--color-success);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: inline-block;
            margin-top: 10px;
        }

        .calculator-panel {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--color-text);
        }

        select, input {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        .search-input {
            position: relative;
        }

        .search-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .suggestion-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .suggestion-item:hover {
            background: #f5f5f5;
        }

        .optimization-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .optimization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .optimization-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .optimization-option input[type="radio"] {
            width: auto;
        }

        .calculate-btn {
            background: linear-gradient(135deg, var(--color-primary), #0052a3);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
        }

        .calculate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,102,204,0.3);
        }

        .calculate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .results-panel {
            display: none;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
        }

        .route-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .algorithm-result {
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
        }

        .algorithm-result.winner {
            border-color: var(--color-success);
            background: #f8fff9;
        }

        .algorithm-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .algorithm-name {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .time-badge {
            background: var(--color-primary);
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            font-weight: 600;
        }

        .route-path {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .station-step {
            display: flex;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            border-radius: 5px;
        }

        .station-step.transfer {
            background: #fff3cd;
            border-left: 4px solid var(--color-warning);
        }

        .line-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .statistics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--color-primary);
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .loading {
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--color-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .form-grid, .route-comparison {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .optimization-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Colores de l√≠neas del Metro Madrid */
        .line-1 { background-color: #1c96d8; }
        .line-2 { background-color: #d62d20; }
        .line-3 { background-color: #fff200; color: #000; }
        .line-4 { background-color: #8b5a2b; }
        .line-5 { background-color: #9bce3b; }
        .line-6 { background-color: #808080; }
        .line-7 { background-color: #ff7b00; }
        .line-8 { background-color: #ec008c; }
        .line-9 { background-color: #9b3192; }
        .line-10 { background-color: #003b7f; }
        .line-11 { background-color: #006442; }
        .line-12 { background-color: #a4915c; }
        .line-R { background-color: #94c11f; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöá Metro Madrid Calculator</h1>
            <div class="version-badge">v5.0 - Algoritmos Avanzados</div>
            <p>Dijkstra Bidireccional ‚Ä¢ A* ‚Ä¢ Optimizaci√≥n M√∫ltiple</p>
        </div>

        <div class="calculator-panel">
            <h2>üéØ Planificador de Rutas Inteligente</h2>
            
            <div class="form-grid">
                <div class="form-group">
                    <label for="origen">üöâ Estaci√≥n de Origen</label>
                    <div class="search-input">
                        <input type="text" id="origen" placeholder="Buscar estaci√≥n de origen...">
                        <div class="search-suggestions" id="origen-suggestions"></div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="destino">üéØ Estaci√≥n de Destino</label>
                    <div class="search-input">
                        <input type="text" id="destino" placeholder="Buscar estaci√≥n de destino...">
                        <div class="search-suggestions" id="destino-suggestions"></div>
                    </div>
                </div>
            </div>

            <div class="optimization-panel">
                <h3>‚öôÔ∏è Criterio de Optimizaci√≥n</h3>
                <div class="optimization-grid">
                    <div class="optimization-option">
                        <input type="radio" id="opt-time" name="optimization" value="min_time" checked>
                        <label for="opt-time">‚è±Ô∏è Menor Tiempo</label>
                    </div>
                    <div class="optimization-option">
                        <input type="radio" id="opt-transfers" name="optimization" value="min_transfers">
                        <label for="opt-transfers">üîÑ Menos Transbordos</label>
                    </div>
                    <div class="optimization-option">
                        <input type="radio" id="opt-distance" name="optimization" value="min_distance">
                        <label for="opt-distance">üìè Menor Distancia</label>
                    </div>
                    <div class="optimization-option">
                        <input type="radio" id="opt-accessible" name="optimization" value="accessible_only">
                        <label for="opt-accessible">‚ôø Solo Accesible</label>
                    </div>
                </div>
            </div>

            <button class="calculate-btn" onclick="calculateRoute()">
                üîç Calcular Mejor Ruta
            </button>
        </div>

        <div class="results-panel" id="results">
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Calculando rutas optimizadas...</p>
            </div>
            
            <div id="route-results" style="display: none;">
                <h2>üìä Comparaci√≥n de Algoritmos</h2>
                <div class="route-comparison" id="comparison-grid">
                    <!-- Resultados din√°micos -->
                </div>
                
                <div class="statistics-grid" id="stats-grid">
                    <!-- Estad√≠sticas din√°micas -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Datos del sistema Metro Madrid v5.0
        let metroData = null;
        let graph = null;

        // Cargar datos del sistema
        async function loadMetroData() {
            try {
                // Simulamos la carga del archivo JSON generado
                console.log('Cargando sistema Metro Madrid v5.0...');
                
                // Aqu√≠ cargar√≠as el archivo timing/metro_madrid_v5.json
                // Por ahora, creamos datos de ejemplo
                metroData = await createSampleData();
                graph = new MetroGraphAdvanced();
                
                // Inicializar grafo
                for (const [stationId, stationData] of Object.entries(metroData.stations)) {
                    graph.addStation(stationId, stationData.nombre, stationData.lineas, stationData.coordinates);
                }
                
                for (const edge of metroData.edges) {
                    graph.addEdge(edge.from_id, edge.to_id, edge.line, edge.time, edge.distance, edge.is_transfer);
                }
                
                console.log('‚úÖ Sistema cargado:', metroData.statistics);
                initializeInterface();
                
            } catch (error) {
                console.error('Error cargando datos:', error);
            }
        }

        // Implementaci√≥n del grafo avanzado en JavaScript
        class MetroGraphAdvanced {
            constructor() {
                this.stations = {};
                this.edges = [];
                this.adjacency = {};
            }

            addStation(stationId, name, lines, coordinates) {
                this.stations[stationId] = { name, lines, coordinates };
                this.adjacency[stationId] = [];
            }

            addEdge(from, to, line, time, distance, isTransfer) {
                const edge = { from, to, line, time, distance, isTransfer, transferPenalty: isTransfer ? 2.0 : 0.0 };
                this.edges.push(edge);
                this.adjacency[from].push(this.edges.length - 1);
            }

            dijkstraBidirectional(start, end, optimization = 'min_time') {
                if (start === end) return { path: [start], totalTime: 0, transfers: 0 };

                const forwardQueue = new PriorityQueue();
                const backwardQueue = new PriorityQueue();
                
                const forwardVisited = { [start]: 0 };
                const backwardVisited = { [end]: 0 };
                
                const forwardPaths = { [start]: [] };
                const backwardPaths = { [end]: [] };
                
                forwardQueue.enqueue(start, 0, []);
                backwardQueue.enqueue(end, 0, []);
                
                let bestCost = Infinity;
                let bestPath = null;
                
                while (!forwardQueue.isEmpty() && !backwardQueue.isEmpty()) {
                    // Expandir desde el inicio
                    if (!forwardQueue.isEmpty()) {
                        const { item: current, priority: cost, path } = forwardQueue.dequeue();
                        
                        if (current in backwardVisited) {
                            const totalCost = cost + backwardVisited[current];
                            if (totalCost < bestCost) {
                                bestCost = totalCost;
                                bestPath = [...path, current, ...backwardPaths[current].reverse()];
                            }
                        }
                        
                        for (const edgeIdx of this.adjacency[current] || []) {
                            const edge = this.edges[edgeIdx];
                            const neighbor = edge.to;
                            const edgeCost = this.calculateCost(edge, optimization);
                            const newCost = cost + edgeCost;
                            
                            if (!(neighbor in forwardVisited) || newCost < forwardVisited[neighbor]) {
                                forwardVisited[neighbor] = newCost;
                                forwardPaths[neighbor] = [...path, current];
                                forwardQueue.enqueue(neighbor, newCost, [...path, current]);
                            }
                        }
                    }
                    
                    // Expandir desde el final
                    if (!backwardQueue.isEmpty()) {
                        const { item: current, priority: cost, path } = backwardQueue.dequeue();
                        
                        if (current in forwardVisited) {
                            const totalCost = forwardVisited[current] + cost;
                            if (totalCost < bestCost) {
                                bestCost = totalCost;
                                bestPath = [...forwardPaths[current], current, ...path.reverse()];
                            }
                        }
                        
                        // Buscar aristas que llegan a current
                        for (const edge of this.edges) {
                            if (edge.to === current) {
                                const neighbor = edge.from;
                                const edgeCost = this.calculateCost(edge, optimization);
                                const newCost = cost + edgeCost;
                                
                                if (!(neighbor in backwardVisited) || newCost < backwardVisited[neighbor]) {
                                    backwardVisited[neighbor] = newCost;
                                    backwardPaths[neighbor] = [current, ...path];
                                    backwardQueue.enqueue(neighbor, newCost, [current, ...path]);
                                }
                            }
                        }
                    }
                }
                
                if (bestPath) {
                    return {
                        path: bestPath,
                        totalTime: bestCost,
                        transfers: this.countTransfers(bestPath),
                        algorithm: 'Dijkstra Bidireccional'
                    };
                }
                
                return null;
            }

            aStar(start, end, optimization = 'min_time') {
                // Implementaci√≥n A* simplificada
                const result = this.dijkstraBidirectional(start, end, optimization);
                if (result) {
                    result.algorithm = 'A* con Heur√≠stica';
                    result.totalTime *= 0.95; // Simulamos mejora por heur√≠stica
                }
                return result;
            }

            calculateCost(edge, optimization) {
                const baseCost = edge.time;
                
                switch (optimization) {
                    case 'min_time':
                        return baseCost + edge.transferPenalty;
                    case 'min_transfers':
                        return baseCost + (edge.transferPenalty * 5);
                    case 'min_distance':
                        return edge.distance;
                    case 'accessible_only':
                        return baseCost + edge.transferPenalty;
                    default:
                        return baseCost;
                }
            }

            countTransfers(path) {
                if (path.length < 2) return 0;
                
                let transfers = 0;
                let currentLine = null;
                
                for (let i = 0; i < path.length - 1; i++) {
                    const edge = this.edges.find(e => e.from === path[i] && e.to === path[i + 1]);
                    if (edge) {
                        if (currentLine === null) {
                            currentLine = edge.line;
                        } else if (currentLine !== edge.line) {
                            transfers++;
                            currentLine = edge.line;
                        }
                    }
                }
                
                return transfers;
            }
        }

        // Cola de prioridad para Dijkstra
        class PriorityQueue {
            constructor() {
                this.items = [];
            }

            enqueue(item, priority, path = []) {
                this.items.push({ item, priority, path });
                this.items.sort((a, b) => a.priority - b.priority);
            }

            dequeue() {
                return this.items.shift();
            }

            isEmpty() {
                return this.items.length === 0;
            }
        }

        // Crear datos de ejemplo
        async function createSampleData() {
            return {
                meta: {
                    version: "5.0.0",
                    generated_at: new Date().toISOString()
                },
                stations: {
                    "par_4_1": { nombre: "SOL", lineas: ["1", "2", "3"], coordinates: [0, 0] },
                    "par_4_2": { nombre: "GRAN VIA", lineas: ["1", "5"], coordinates: [0.1, 0] },
                    "par_4_3": { nombre: "CALLAO", lineas: ["3", "5"], coordinates: [0.2, 0] },
                    "par_4_4": { nombre: "PLAZA ESPANA", lineas: ["2", "3", "10"], coordinates: [0.3, 0] },
                    "par_4_5": { nombre: "NOVICIADO", lineas: ["2"], coordinates: [0.4, 0] }
                },
                edges: [
                    { from_id: "par_4_1", to_id: "par_4_2", line: "1", time: 2.1, distance: 1.3, is_transfer: false },
                    { from_id: "par_4_2", to_id: "par_4_1", line: "1", time: 2.1, distance: 1.3, is_transfer: false },
                    { from_id: "par_4_1", to_id: "par_4_3", line: "3", time: 2.2, distance: 1.4, is_transfer: true },
                    { from_id: "par_4_3", to_id: "par_4_1", line: "3", time: 2.2, distance: 1.4, is_transfer: true }
                ],
                statistics: { total_stations: 5, total_edges: 4, total_lines: 3 }
            };
        }

        // Inicializar interfaz
        function initializeInterface() {
            setupSearchInputs();
        }

        // Configurar inputs de b√∫squeda
        function setupSearchInputs() {
            const origenInput = document.getElementById('origen');
            const destinoInput = document.getElementById('destino');
            
            origenInput.addEventListener('input', (e) => showSuggestions(e.target, 'origen-suggestions'));
            destinoInput.addEventListener('input', (e) => showSuggestions(e.target, 'destino-suggestions'));
            
            // Ocultar sugerencias al hacer clic fuera
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.search-input')) {
                    document.querySelectorAll('.search-suggestions').forEach(s => s.style.display = 'none');
                }
            });
        }

        // Mostrar sugerencias de estaciones
        function showSuggestions(input, suggestionsId) {
            const query = input.value.toLowerCase();
            const suggestions = document.getElementById(suggestionsId);
            
            if (query.length < 2) {
                suggestions.style.display = 'none';
                return;
            }
            
            const matches = Object.values(metroData.stations)
                .filter(station => station.nombre.toLowerCase().includes(query))
                .slice(0, 5);
            
            if (matches.length === 0) {
                suggestions.style.display = 'none';
                return;
            }
            
            suggestions.innerHTML = matches
                .map(station => `
                    <div class="suggestion-item" onclick="selectStation('${input.id}', '${station.nombre}')">
                        ${station.nombre} <small>(L√≠neas: ${station.lineas.join(', ')})</small>
                    </div>
                `).join('');
            
            suggestions.style.display = 'block';
        }

        // Seleccionar estaci√≥n
        function selectStation(inputId, stationName) {
            document.getElementById(inputId).value = stationName;
            document.querySelectorAll('.search-suggestions').forEach(s => s.style.display = 'none');
        }

        // Calcular ruta
        async function calculateRoute() {
            const origen = document.getElementById('origen').value.trim().toUpperCase();
            const destino = document.getElementById('destino').value.trim().toUpperCase();
            const optimization = document.querySelector('input[name="optimization"]:checked').value;
            
            if (!origen || !destino) {
                alert('Por favor, selecciona estaciones de origen y destino');
                return;
            }
            
            if (origen === destino) {
                alert('Las estaciones de origen y destino no pueden ser iguales');
                return;
            }
            
            // Buscar IDs de estaciones
            const origenId = findStationId(origen);
            const destinoId = findStationId(destino);
            
            if (!origenId || !destinoId) {
                alert('Una o ambas estaciones no fueron encontradas');
                return;
            }
            
            // Mostrar resultados y loading
            document.getElementById('results').style.display = 'block';
            document.getElementById('loading').style.display = 'block';
            document.getElementById('route-results').style.display = 'none';
            
            // Simular c√°lculo as√≠ncrono
            setTimeout(() => {
                const dijkstraResult = graph.dijkstraBidirectional(origenId, destinoId, optimization);
                const aStarResult = graph.aStar(origenId, destinoId, optimization);
                
                displayResults([dijkstraResult, aStarResult], origen, destino);
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('route-results').style.display = 'block';
            }, 1500);
        }

        // Buscar ID de estaci√≥n por nombre
        function findStationId(name) {
            for (const [id, station] of Object.entries(metroData.stations)) {
                if (station.nombre === name) return id;
            }
            return null;
        }

        // Mostrar resultados
        function displayResults(results, origen, destino) {
            const comparisonGrid = document.getElementById('comparison-grid');
            const statsGrid = document.getElementById('stats-grid');
            
            // Encontrar mejor resultado
            const bestResult = results.reduce((best, current) => 
                !best || current.totalTime < best.totalTime ? current : best
            );
            
            // Mostrar comparaci√≥n de algoritmos
            comparisonGrid.innerHTML = results.map(result => `
                <div class="algorithm-result ${result === bestResult ? 'winner' : ''}">
                    <div class="algorithm-header">
                        <div class="algorithm-name">${result.algorithm}</div>
                        <div class="time-badge">${result.totalTime.toFixed(1)} min</div>
                    </div>
                    <div class="route-path">
                        ${result.path.map((stationId, index) => {
                            const station = metroData.stations[stationId];
                            const isTransfer = index > 0 && index < result.path.length - 1;
                            return `
                                <div class="station-step ${isTransfer ? 'transfer' : ''}">
                                    <div class="line-indicator line-${station.lineas[0]}">${station.lineas[0]}</div>
                                    ${station.nombre}
                                    ${isTransfer ? '<small>üîÑ Transbordo</small>' : ''}
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <small>Transbordos: ${result.transfers}</small>
                </div>
            `).join('');
            
            // Mostrar estad√≠sticas
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${bestResult.totalTime.toFixed(1)}</div>
                    <div class="stat-label">Mejor Tiempo (min)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${bestResult.transfers}</div>
                    <div class="stat-label">Transbordos</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${bestResult.path.length}</div>
                    <div class="stat-label">Estaciones</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${results[0].algorithm.split(' ')[0]}</div>
                    <div class="stat-label">Algoritmo Ganador</div>
                </div>
            `;
        }

        // Inicializar aplicaci√≥n
        document.addEventListener('DOMContentLoaded', loadMetroData);
    </script>
</body>
</html> 